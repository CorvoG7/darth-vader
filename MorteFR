import robocode.*;

public class MorteFR extends AdvancedRobot {
    private double myX;
    private double myY;
    private double myHeading;
    private double myEnergy;
    private double enemyX;
    private double enemyY;
    private double enemyHeading;
    private double enemyEnergy;

    public void run() {
        while (true) {
            updateMyInfo();
            updateEnemyInfo();
            selectStrategy();
            executeStrategy();
            execute();
        }
    }

    private void updateMyInfo() {
        myX = getX();
        myY = getY();
        myHeading = getHeading();
        myEnergy = getEnergy();
    }

    private void updateEnemyInfo() {
        EnemyRobot closestEnemy = getClosestEnemy();
        enemyX = closestEnemy.getX();
        enemyY = closestEnemy.getY();
        enemyHeading = closestEnemy.getHeading();
        enemyEnergy = closestEnemy.getEnergy();
    }

    private EnemyRobot getClosestEnemy() {
        // Implementação para encontrar e retornar o inimigo mais próximo
        // Pode ser baseado em varredura de inimigos ou outras estratégias
        return null; // Retornando null temporariamente
    }

    private void selectStrategy() {
        if (isCloseToEnemy()) {
            attackEnemy();
        } else {
            avoidEnemy();
        }
    }

    private void executeStrategy() {
        if (isCloseToEnemy()) {
            fire(1);
        } else {
            turnRight(90);
            ahead(100); // Movendo para frente
        }
    }

    private void attackEnemy() {
        fire(1);
    }

    private void avoidEnemy() {
        turnRight(90);
        ahead(100); // Movendo para frente
    }

    private boolean isCloseToEnemy() {
        return getDistanceToEnemy() < 50;
    }

    private double getDistanceToEnemy() {
        return Math.sqrt(Math.pow(enemyX - myX, 2) + Math.pow(enemyY - myY, 2));
    }
}
