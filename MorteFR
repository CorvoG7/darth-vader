import robocode.*;
import java.awt.Color;

public class MorteFR extends AdvancedRobot {
    private static final double FIRE_POWER = 3; // Poder de fogo dos tiros
    private static final double MOVE_DISTANCE = 100; // Distância de movimento
    private static final double WALL_MARGIN = 40; // Margem de segurança em relação às paredes

    public void run() {
        setColors(Color.red, Color.blue, Color.green); // Configuração das cores

        while (true) {
            mover(); // Comportamento de movimento
            mirar(); // Comportamento de mira
            execute(); // Execução dos comandos
        }
    }

    public void onScannedRobot(ScannedRobotEvent e) {
        double absoluteBearing = getHeadingRadians() + e.getBearingRadians();
        double bearingFromGun = robocode.util.Utils.normalRelativeAngle(absoluteBearing - getGunHeadingRadians());
        turnGunRightRadians(bearingFromGun);

        if (Math.abs(bearingFromGun) <= 3) {
            fire(FIRE_POWER);
        }
    }

    public void onHitByBullet(HitByBulletEvent e) {
        // Quando atingido por um tiro, inverte a direção
        setAhead(MOVE_DISTANCE * -1);
        execute();
    }

    public void onHitWall(HitWallEvent e) {
        // Quando atinge a parede, faz uma manobra para se afastar
        setBack(MOVE_DISTANCE);
        execute();
    }

    private void mover() {
        // Movimento circular linear antecipado para desviar dos tiros
        double angle = getHeadingRadians() + Math.PI / 2 * Math.signum(Math.sin(getTime() / 5));
        double x = getX() + MOVE_DISTANCE * Math.sin(angle);
        double y = getY() + MOVE_DISTANCE * Math.cos(angle);

        // Verifica se está perto das paredes e ajusta o movimento para evitar colisões
        if (x > WALL_MARGIN && y > WALL_MARGIN && x < getBattleFieldWidth() - WALL_MARGIN && y < getBattleFieldHeight() - WALL_MARGIN) {
            setAhead(MOVE_DISTANCE);
            setTurnRightRadians(Math.tan(Math.PI / 2 * Math.signum(Math.sin(getTime() / 5))));
        } else {
            setAhead(MOVE_DISTANCE * -1);
            setTurnRightRadians(Math.tan(Math.PI / 2 * Math.signum(Math.sin(getTime() / 5))));
        }
    }

    private void mirar() {
        // Mantém o radar girando para procurar inimigos
        setTurnRadarRightRadians(Double.POSITIVE_INFINITY);
    }
}

