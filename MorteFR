import robocode.*;
import java.awt.Color;

public class MorteFR extends AdvancedRobot {
    private double enemyX;
    private double enemyY;
    private double enemyHeading;
    private double enemyEnergy;
    private double myEnergy;

    public void run() {
        setColors(Color.BLUE, Color.BLUE, Color.BLUE); // Definir cores do rob√¥

        while (true) {
            updateEnemyInfo();
            updateMyInfo();
            selectStrategy();
            executeStrategy();
            execute();
        }
    }

    private void updateEnemyInfo() {
        ScannedRobotEvent closestEnemy = getClosestEnemy();
        if (closestEnemy != null) {
            double angleToEnemy = getHeadingRadians() + closestEnemy.getBearingRadians();
            enemyX = getX() + Math.sin(angleToEnemy) * closestEnemy.getDistance();
            enemyY = getY() + Math.cos(angleToEnemy) * closestEnemy.getDistance();
            enemyHeading = closestEnemy.getHeading();
            enemyEnergy = closestEnemy.getEnergy();
        }
    }

    private void updateMyInfo() {
        myEnergy = getEnergy();
    }

    private ScannedRobotEvent getClosestEnemy() {
        return getScannedRobotEvents().stream()
                .filter(this::isEnemyIdentified)
                .min(Comparator.comparing(ScannedRobotEvent::getDistance))
                .orElse(null);
    }

    private boolean isEnemyIdentified(ScannedRobotEvent enemy) {
        return !new Teammate(enemy.getName()).isTeammate() && enemy.getDistance() < 100 && enemy.getEnergy() > myEnergy;
    }

    private void selectStrategy() {
        if (isCloseToEnemy()) {
            if (shouldAttack()) {
                attackEnemy();
            } else {
                evadeEnemy();
            }
        } else {
            chaseEnemy();
        }
    }

    private void executeStrategy() {
        if (isCloseToEnemy()) {
            if (shouldAttack()) {
                turnGunToEnemy();
                fire(1);
            } else {
                turnRight(90);
                ahead(100);
            }
        } else {
            turnTowardsEnemy();
            ahead(100);
        }
    }

    private void attackEnemy() {
        turnGunToEnemy();
        fire(1);
    }

    private void evadeEnemy() {
        turnRight(90);
        ahead(100);
    }

    private void chaseEnemy() {
        turnTowardsEnemy();
        ahead(100);
    }

    private boolean isCloseToEnemy() {
        return getDistanceToEnemy() < 100;
    }

    private boolean shouldAttack() {
        return myEnergy > enemyEnergy;
    }

    private void turnTowardsEnemy() {
        double bearing = Utils.normalRelativeAngle(Math.atan2(enemyX - getX(), enemyY - getY()) - getHeadingRadians());
        turnRight(Math.toDegrees(bearing));
    }

    private void turnGunToEnemy() {
        double bearing = Utils.normalRelativeAngle(Math.atan2(enemyX - getX(), enemyY - getY()) - getGunHeadingRadians());
        turnGunRight(Math.toDegrees(bearing));
    }

    private double getDistanceToEnemy() {
        return Math.hypot(enemyX - getX(), enemyY - getY());
    }
}
